from ImageData import *
from GAagent import *
from matplotlib import pyplot as plt
import os, random, time
import numpy as np
from PIL import Image


class Environement:

    KnnTrainingData = None
    TrainingFileNameKnn = "./trainingFile.txt"
    directoryList = ['./trainFold1.txt', './trainFold2.txt', './trainFold3.txt',
                     './validationFold1.txt', './validationFold2.txt', './validationFold3.txt']
    Round1TrainingFile = directoryList[0]
    Round2TrainingFile = directoryList[1]
    Round3TrainingFile = directoryList[2]

    Round1ValidationFile = directoryList[3]
    Round2ValidationFile = directoryList[4]
    Round3ValidationFile = directoryList[5]

    FlagsToCluster = {}

    def __init__(self):
        self.KnnTrainingData = {}
        self.FlagsToCluster = {}

    def invalidKvalue(self, Kstr):
        #this method validates k values
        if Kstr.isdigit():
            if int(Kstr) == 0:
                return True
            else:
                return False
        else:
            return True

    def loadKnnTrainingData(self, iProcessor):
        #this method loads training data for Knn

        if (os.path.isfile(self.TrainingFileNameKnn)):
            print "\nData is available in external file."
            if (self.readFromExternalFile()):
                return True

        print '\nLoading data for 124 files... This may take some time.'
        path = "./trainingData/headshots"
        i = 0
        try:
            for f in os.listdir(path):
                print "Extracting features for Image"+ str(i+1)+" : \t"+str(f)
                imgName = "timage" + str(i)
                img = ImageData(imgName, [], "headshot", f)
                img.imageData = Image.open(os.path.join(path, f))
                i += 1
                img.featureVector = iProcessor.fetchFeatureVector(img)
                self.KnnTrainingData[img] = img.featureVector

        except Exception as e:
            print 'Failed to load Training Data from ' + path
            print e.message
            return False

        try:
            path = "./trainingData/landscapes"
            for f in os.listdir(path):
                print "Extracting features for Image : \t" + str(f)
                imgName = "timage" + str(i)
                img = ImageData(imgName, [], "landscape", f)
                img.imageData = Image.open(os.path.join(path, f))
                i += 1
                img.featureVector = iProcessor.fetchFeatureVector(img)
                self.KnnTrainingData[img] = img.featureVector
        except Exception as e:
            print 'Failed to load Training Data from ' + path
            print e.message
            return False

        print "\nTraining Data Loaded..."

        self.writeToExternalFile()

        return True

    def writeToExternalFile(self):
        #this method writes training data to external file for fast computations

        print '\nWriting to external file..'

        try:
            f = open(self.TrainingFileNameKnn, 'w')

            for key in self.KnnTrainingData.keys():
                name = key.imageName
                label = key.label
                actualName = key.imageActualName
                featureArray = self.KnnTrainingData[key]
                line = name + " " + str(featureArray) + " " + label + " " + actualName + "\n"
                f.write(line)

            f.close()

        except Exception:
            print 'Failed to write to external file ' + self.TrainingFileNameKnn
            os.remove(self.TrainingFileNameKnn)

    def readFromExternalFile(self):
        #this method reads and deserializes training data from external file

        print '\nLoading data from external file...'
        try:
            f = open(self.TrainingFileNameKnn, 'r')
            for line in f.readlines():
                line = line.replace('[', ' ').replace(']', ' ').replace(',', ' ').split()
                nameStr = line[0]
                featureStr = [line[1], line[2], line[3], line[4]]
                features = []
                for i in range(len(featureStr)):
                    features.append(float(featureStr[i]))
                labelStr = line[5]
                actualNameStr = line[6]
                img = ImageData(nameStr, features, labelStr, actualNameStr)
                self.KnnTrainingData[img] = img.featureVector

            f.close()
            return True

        except Exception as e:
            print 'Training File not found ' + self.TrainingFileNameKnn
            print e.message
            return False

    def readFromDataset(self, file):
        #this method reads from external fold files generated by program automatically
        Data = {}

        try:
            f = open(file, 'r')
            for line in f.readlines():
                line = line.replace('[', ' ').replace(']', ' ').replace(',', ' ').split()
                nameStr = line[0]
                featureStr = [line[1], line[2], line[3], line[4]]
                features = []
                for i in range(len(featureStr)):
                    features.append(float(featureStr[i]))
                labelStr = line[5]
                actualNameStr = line[6]
                img = ImageData(nameStr, features, labelStr, actualNameStr)
                Data[img] = img.featureVector

            f.close()

        except Exception as e:
            print 'Dataset File not found ' + file
            print e.message

        return Data

    def classifyImage(self, iAgent, iProcessor):
        #this method initiates Knn classification

        loadSuccess = self.loadKnnTrainingData(iProcessor)

        if not loadSuccess:
            print "Failed to load training data.. Try Again and check training input dirs"
            return

        print "\nPLEASE MAKE SURE THAT YOUR IMAGE FILES TO CLASSIFY ARE PLACED IN DIRECTORY: ./ImagesToClassify"

        Kstr = raw_input("\nEnter value of K for Knn:\t").strip()
        if (self.invalidKvalue(Kstr)):
            print "\nInvalid value for K. Please enter positive integer value greater than 0."
            return

        K = int(Kstr)

        noOfTrainingRecords = len(self.KnnTrainingData.keys())
        if (K > noOfTrainingRecords):
            print "\nK value is greater than number of training files available."
            print "Setting K value to number of training files available..."
            K = noOfTrainingRecords - 1
            print "\nSetting K to " + str(K)

        imagesToClassify = {}

        img_dir = "./ImagesToClassify"

        #loading images to classify
        data = iProcessor.loadImagesToClassify(img_dir)
        if data == []:
            print "No image files found at path mentioned below."
            print img_dir
            print "Please try again."
            return

        print "\n"
        #extracting features for images to classify
        for img in data:
            print "Extracting features for Image :\t"+str(img.imageActualName)
            img.featureVector = iProcessor.fetchFeatureVector(img)
            imagesToClassify[img] = img.featureVector

        print "\n\n--------------------Classification Started!-------------------------"
        for img in imagesToClassify.keys():
            percept = imagesToClassify[img]
            prediction = iAgent.knnPredict(percept, self.KnnTrainingData, K)
            img.label = prediction
            print "Image Name:\t" + img.imageActualName
            print "\tClassifier labelled image as : \t" + img.label
            print "-----------------------------------------------"
            self.showImage(img, prediction)

    def crossValidation(self, iAgent, iProcessor):
        #this method initiates 3-fold cross validation

        print '\nInitiating 3-fold cross validation'

        loadSuccess = self.loadKnnTrainingData(iProcessor)

        if not loadSuccess:
            print "Failed to load training data.. Try Again and check training input dirs"
            return

        foldCreationSuccess = iProcessor.create3Folds(self.KnnTrainingData)

        if not foldCreationSuccess:
            print "Failed to create folds.. Try Again and check training data"
            return

        # implement cross validation

        print "\nCross-validation round 1:"
        self.performCrossValidation(self.Round1TrainingFile, self.Round1ValidationFile, iAgent, 1)
        print "\nCross-validation round 2:"
        self.performCrossValidation(self.Round2TrainingFile, self.Round2ValidationFile, iAgent, 2)
        print "\nCross-validation round 3:"
        self.performCrossValidation(self.Round3TrainingFile, self.Round3ValidationFile, iAgent, 3)

    def performCrossValidation(self, trainingFile, validationFile, iAgent, roundNumber):
        #this method performs cross validation for fiven training and validation folds
        #it also analyzes and computes accuracy of a fold for different K values

        print "\nAnalyzing Average Accuracy values for different values of K(1,3,5,7,9)\n"
        AccuraciesForVariableK = []
        xAxis = []
        yAxis = []

        for k_value in range(1, 10):
            #for k odd values
            if (k_value % 2 != 0):

                xAxis.append(k_value)

                predictions = []

                print "For K = " + str(k_value) + " -->"

                validationData = self.readFromDataset(validationFile)
                trainingData = self.readFromDataset(trainingFile)

                validationArray = validationData.keys()

                for key in validationArray:
                    pred = iAgent.knnPredict(key.featureVector, trainingData, k_value)
                    predictions.append((key, pred))

                accuracy = self.findAverageAccuracy(predictions)

                yAxis.append(accuracy)

                AccuraciesForVariableK.append((k_value, accuracy))

                print "Average Accuracy of a classifier :\t" + str(accuracy) + "%\n"

        self.plotGraph(xAxis, yAxis, roundNumber)

        print "\nAccuracy percentage for different K values :\n"
        for acc in AccuraciesForVariableK:
            print "\tK = " + str(acc[0]) + " : " + str(acc[1])+" %"

    def findAverageAccuracy(self, preds):
        #this method computes average accuracy for given predictions

        correct = 0

        for i in range(0, len(preds)):
            if (preds[i][0].label == preds[i][1]):
                correct += 1
        accuracyPercentage = (float(correct) / len(preds)) * 100

        return accuracyPercentage

    def performKmeansClustering(self, iAgent, iProcessor):
        #this method initiates k-means clustering algorithm for headset and landscape datasets

        loadSuccess = self.loadKnnTrainingData(iProcessor)

        if not loadSuccess:
            print "Failed to load data.. Try Again and check training input dirs"
            return

        images = self.KnnTrainingData.keys()
        centroids = []
        temp_imgs = []
        clusters = 2
        itr = 0

        # randomly select initial centroids
        for c_index in range(clusters):
            while True:
                random_image = images[random.randint(1, len(images) - 1)]
                if not temp_imgs.__contains__(random_image):
                    break
            temp_imgs.append(random_image)
            centroids.append(random_image.featureVector)

        #initiaing k means for random centroids
        output = self.kmeans(clusters, centroids, images, itr, iAgent)
        clustered_images = output[0]

        for i in range(len(clustered_images)):
            print "\nCluster " + str(i + 1) + " =>\n"
            cl = clustered_images[i]
            for img in cl:
                print img.label + "-" + img.imageActualName

        #cluster analysis
        print "\n\nCluster Analysis =>\n"
        for i in range(len(clustered_images)):
            print "\nCluster " + str(i + 1) + " =>\n"
            cl = clustered_images[i]
            headshotN = 0
            landscapeN = 0
            for img in cl:
                if img.label == "headshot":
                    headshotN += 1
                else:
                    landscapeN += 1
            print "Total no. of images in this cluster:\t" + str(len(cl))
            print "Headshot image count :\t" + str(headshotN)
            print "Landscape image count :\t" + str(landscapeN)

        print "\nPlease scroll up to see the clustered images."

    def kmeans(self, k, centroids, images, itr, iAgent):
        #this is a looped method which computes closest centroids for each image in cluster

        clusters = [[] for i in range(k)]

        # finding closest centroid for each job document in cluster
        for i in range(len(images)):
            datapoint = images[i].featureVector
            clusterIdentifier = self.findClosestCentroid(datapoint, centroids, iAgent)
            images[i].clusterID = clusterIdentifier
            clusters[clusterIdentifier].append(images[i])

        newCentroids = self.findNewCentroid(clusters, iAgent)

        if not self.equals(centroids, newCentroids, iAgent):
            #termination condition
            print "Iteration " + str(itr)
            itr += 1
            clusters = self.kmeans(k, newCentroids, images, itr, iAgent)

        return (clusters, newCentroids)

    def findClosestCentroid(self, datapoint, centroids, agent):
        #this method finds closest centroid to the given image datapoint

        c0 = centroids[0]
        c1 = centroids[1]
        d0 = agent.calculateEucledeanDistance(c0, datapoint)
        d1 = agent.calculateEucledeanDistance(c1, datapoint)

        if d0 > d1:
            return 1
        return 0

    def findNewCentroid(self, clusters, agent):
        #this method finds new centroids for given clusters

        newCentroids = []

        cluster0 = clusters[0]
        cluster1 = clusters[1]

        # Find mean vector for each centroid group and add new centroid
        f1 = 0
        f2 = 0
        f3 = 0
        f4 = 0
        meanVectorg0 = []
        for i in range(len(cluster0)):
            f1 += cluster0[i].featureVector[0]
            f2 += cluster0[i].featureVector[1]
            f3 += cluster0[i].featureVector[2]
            f4 += cluster0[i].featureVector[3]
        meanVectorg0.append(float(f1) / len(cluster0))
        meanVectorg0.append(float(f2) / len(cluster0))
        meanVectorg0.append(float(f3) / len(cluster0))
        meanVectorg0.append(float(f4) / len(cluster0))

        f1 = 0
        f2 = 0
        f3 = 0
        f4 = 0
        meanVectorg1 = []
        for i in range(len(cluster1)):
            f1 += cluster1[i].featureVector[0]
            f2 += cluster1[i].featureVector[1]
            f3 += cluster1[i].featureVector[2]
            f4 += cluster1[i].featureVector[3]
        meanVectorg1.append(float(f1) / len(cluster1))
        meanVectorg1.append(float(f2) / len(cluster1))
        meanVectorg1.append(float(f3) / len(cluster1))
        meanVectorg1.append(float(f4) / len(cluster1))

        newCentroids.append(meanVectorg0)
        newCentroids.append(meanVectorg1)
        return newCentroids

    def equals(self, centroids, newCentroids, iAgent):
        #this method checks the termination condition for k-means
        if len(centroids) != len(newCentroids):
            return False

        for i in range(len(centroids)):
            d = iAgent.calculateEucledeanDistance(centroids[i], newCentroids[i])
            if d == 0:
                return True

        return True

    def plotGraph(self, x, y, roundNumber):
        # ploting graph of K vs average accuracy
        x_axis = np.array(x)
        y_axis = np.array(y)
        plt.plot(x_axis, y_axis)
        plt.xlabel('X-axis  -  K')
        plt.ylabel('Y-axis  - Accuracy (%)')
        title = '\n Please close the image to proceed further\nFold' + str(roundNumber) + ' : K vs Accuracy (%)'
        plt.title(title)
        plt.tight_layout()
        plt.show()
        plt.close()

    def loadFlagImages(self, iProcessor):
        #this method loads flag images for hierarchical clustering

        print "Loading and extracting features for flag images...This may take some time"
        flags = next(os.walk('./flags'))[2]
        self.FlagsToCluster = {}
        for i in range(len(flags)):
            print "Extracting features for flag image:\t"+str(flags[i])
            flagName = "flag" + str(i + 1)
            flag = Image.open('./flags/' + flags[i])
            features = iProcessor.extractColorFeature(flag)
            image = ImageData(flagName, features, "flag", flags[i])
            image.featureVector = features
            self.FlagsToCluster[image] = image.featureVector

    def performSingleLinkClustering(self, images, iAgent):
        #this method initiates single link clustering algorithm for given image dataset

        #counter value to iterate over all images
        counter = len(images)
        distances = {}

        #initializing group for every image or a singleton cluster for every image
        for i in range(len(images)):
            images[i].group = {}

        #initializing dictionary to store euclidean distances for each image from every other image
        for i in range(len(images)):
            distances[i] = {}

        print "Clustering images.. Please be patient as this may take some time"
        minimumValue1 = 0
        minimumValue2 = 0
        while counter > 0:
            minimumD = sys.maxint
            for i in range(len(images)):
                for j in range(len(images)):
                    #condition to exclude distance calculation of an image with itself
                    if(i != j) :
                        if counter == len(images):
                            # calculating euclidean distance of every image with every other image
                            distances[i][j] = iAgent.calculateEucledeanDistance(images[i].featureVector, images[j].featureVector)
                        else:
                            #finding minimum distances between different clusters
                            distances[i][j] = self.calculateMinimumDistance(images[i].group[counter + 1], images[j].group[counter + 1], distances)
                        #changing the minimum distace value
                        if minimumD > distances[i][j]:
                            minimumValue1 = i
                            minimumValue2 = j
                            minimumD = distances[i][j]

            if counter != len(images):
                images[minimumValue1].group[counter] = list(images[minimumValue1].group[counter + 1])

                for index in images[minimumValue2].group[counter + 1]:
                    if index not in images[minimumValue1].group[counter]:
                        images[minimumValue1].group[counter].append(index)
                images[minimumValue2].group[counter] = list(images[minimumValue2].group[counter + 1])

                for index in images[minimumValue1].group[counter + 1]:
                    if index not in images[minimumValue2].group[counter]:
                        images[minimumValue2].group[counter].append(index)

                for index in range(len(images)):
                    if index == minimumValue1 or index == minimumValue2:
                        continue
                    images[index].group[counter] = list(images[index].group[counter + 1])

                for image in images[minimumValue1].group[counter]:
                    if image != minimumValue1 and image != minimumValue2:
                        for index in images[minimumValue1].group[counter]:
                            if index not in images[image].group[counter]:
                                images[image].group[counter].append(index)
            else:
                for i in range(len(images)):
                    if i != minimumValue1 and i != minimumValue2:
                        images[i].group[counter] = [i]
                    if i == minimumValue1:
                        images[i].group[counter] = [i, minimumValue2]
                    elif i == minimumValue2:
                        images[i].group[counter] = [minimumValue1, i]

            counter -= 1

        for index in range(1, len(images)):
            for image in images:
                image.group[index] = sorted(image.group[index])

        levels = {}
        for level in range(1, len(images) + 1):
            clusters = []
            for image in images:
                if image.group[level] not in clusters:
                    clusters.append(image.group[level])
            levels[level] = clusters

        for key in levels.keys():
            print "\tLevel " + str(key) + " ==>>"
            for index in range(len(levels[key])):
                print "\t\t\tCluster " + str(index + 1) + "==>> [",
                for img_index in levels[key][index]:
                    print "\n\t\t\t\t",
                    print images[img_index].imageActualName + " [",
                    print images[img_index].label + "]",
                print " ]"

    def calculateMinimumDistance(self, cluster1, cluster2, distances):
        #this method finds minimum distance between two given clusters
        minimumD = sys.maxint
        c1 = sorted(cluster1)
        c2 = sorted(cluster2)

        if c1 != c2:
            for i in cluster1:
                for j in cluster2:
                    if i != j:
                        d = distances[i][j]
                        if minimumD > d:
                            minimumD = d

        return minimumD

    def evolveOnetoAnother(self):
        #this method initiates GA algorithm to evolve one image into another

        inputImages = {}
        i = 0

        f = next(os.walk('.\EvolveOneFlagToAnother'))[2]

        try:
            for img in f:
                i += 1
                inputImages[i] = img
                print str(i) + ". " + str(img)
        except Exception as e:
            print "No flag files found at path : .\EvolveOneFlagToAnother"

        inputImageText = "\nSelect source image by entering number:\t"

        inputImage = int(raw_input(inputImageText))

        inputImageText = "\nSelect target image by entering number:\t"

        outputImage = int(raw_input(inputImageText))
        try:
            targetImage = Image.open("./EvolveOneFlagToAnother/" + inputImages[outputImage])
            sourceImage = Image.open("./EvolveOneFlagToAnother/" + inputImages[inputImage]).resize(targetImage.size)
        except Exception:
            print "\nNumber you entered is not listed. Please enter number corresponding to image."
            return
        gaAgent = GAagent(sourceImage, targetImage)

        gaAgent.GAAlgorithmFunction()

    def showImage(self,img, predictedLabel):
        img = Image.open("./ImagesToClassify/"+img.imageActualName)
        plt.title("\n Please close the image to proceed further\nPredicted Label:\t"+predictedLabel)
        plt.xticks([])
        plt.yticks([])
        plt.imshow(np.asarray(img))
        plt.tight_layout()
        plt.show()
        plt.close()